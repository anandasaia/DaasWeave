import {includes, debounce, isNil} from "lodash";
import {formatText} from "../../editor/text-format/FormatText";
import {KWILL_CONSTS} from "../../constants/Constants";
import {getSignal} from "../../events/GlobalEvents";
import {sniffFormats} from '../../editor/info/format-sniffer/FormatSniffer';
import {getActiveTextEditorID} from "../../editor/TextEditor";
import {trackEdits} from "../../editor/track-changes/TrackChanges";

export interface IInteractionTarget extends HTMLElement
{
    value: string;
}


/**
 * when the user clicks the text format popup
 * @param event
 */
export let onTextFormatUiClick: (event: MouseEvent) => void = (event: MouseEvent) =>
{
    let target: IInteractionTarget;

    //  get the event target

    target = findValidTarget(event);

    try
    {
        //  test the tag type to determine the right course of action

        switch (target.tagName)
        {
            case 'INPUT':

                let input: HTMLInputElement;

                //  cast to input element

                input = <HTMLInputElement>target;

                //  select input contents

                input.select();

                return;

            case "SELECT":

                return;
        }
    }
    catch (e)
    {
        //  failed, probably because the element has no data-format attribute

        return;
    }

    //  do the associated format UI interaction

    onFormatUiInteraction(event);
};


/**
 * find a valid target
 * @param event
 * @returns {HTMLElement}
 */
export function findValidTarget(event: MouseEvent) : IInteractionTarget
{
    let element: HTMLElement,
        tagNames: string[];

    //  get the current target

    element = <HTMLElement>event.target;

    //  define a list of tag names to use

    tagNames = ['BUTTON', 'INPUT', 'SELECT', 'A'];

    while (element && element.tagName)
    {
        //  if we've found a valid style, return it

        if (includes(tagNames, element.tagName)) return <IInteractionTarget>element;

        //  otherwise, check the element's parent

        element = element.parentElement;
    }
}


/**
 * when the user interacts with a text-format control
 * @param event
 */
export let onFormatUiInteraction: (event: MouseEvent) => void = (event: MouseEvent) =>
{
    let format: string,
        value: string;

    //  get format and value from the control

    format = getDataFormatFromEvent(<HTMLElement>event.target);
    value = getDataValueFromEvent(<IInteractionTarget>event.target);

    //  if we can't find a format or value from the interaction, stop here

    if ( ! format) return;

    // console.log(event.type, ':', format, '=', value);

    //  set the relevant format/value on the current selection

    formatText(format, value);

    //  update the UI to reflect the new text format

    getSignal(KWILL_CONSTS.events.TEXT_FORMAT).dispatch(sniffFormats());

    //  register a change to the editor content

    trackEdits(getActiveTextEditorID());
};


/**
 * test whether the target was a button
 * @param event
 */
function targetIsButton(event: MouseEvent) : boolean
{
    return (<HTMLElement>event.target).tagName === 'BUTTON';
}


/**
 * when the user clicks an element
 * @param event
 */
export let onFormatUiFocus: (event: MouseEvent) => void = (event: MouseEvent) =>
{
    console.log('focus');
};


/**
 * when the user clicks an element
 * @param event
 */
export let onFormatUiBlur: (event: MouseEvent) => void = (event: MouseEvent) =>
{
    console.log('blur');
};


/**
 * when the user clicks an element
 * @param event
 */
export let onFormatUiInput: (event: KeyboardEvent) => void = (event: KeyboardEvent) =>
{
    console.log('input');
};


/**
 * get the data-format property from an event
 * @param element
 * @return {any}
 */
function getDataFormatFromEvent(element: HTMLElement) : string
{
    let format: string;

    //  walk back up the tree until we find a usable data-format

    while (element && element.dataset)
    {
        //  check the element for a usable data-format attribute

        format = element.dataset['format'];

        //  if we've found a valid format, return it

        if (format) return format;

        //  otherwise, check the element's parent

        element = element.parentElement;
    }

    //  no result found

    return null;
}


/**
 * get the data-value property from an event
 * @param element
 * @return {any}
 */
export function getDataValueFromEvent(element: IInteractionTarget)
{
    let value: string;

    //  walk back up the tree until we find a usable data-format

    while (element && element.dataset)
    {
        //  check the element for a usable data-format attribute

        value = getDataValueFromElement(element);

        //  if we've found a valid format, return it

        if (value) return value;

        //  otherwise, check the element's parent

        element = <IInteractionTarget>element.parentElement;
    }

    //  no result found

    return null;
}


/**
 * get the data-value property from an element
 * @returns {string}
 */
export function getDataValueFromElement(target: IInteractionTarget)
{
    return target.dataset['value'] || target.value;
}


