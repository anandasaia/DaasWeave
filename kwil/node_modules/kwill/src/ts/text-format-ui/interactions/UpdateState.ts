import {map, isEmpty} from "lodash";
import {getDataValueFromElement, IInteractionTarget} from "./FormatInteractions";
import {KWILL_CONSTS} from "../../constants/Constants";
import {getTextNodesInRange} from "../../utils/dom/html/range/GetNodesInRange";
import {stripUnits} from "../../editor/text-format/utils/UnitsUtils";
import {ITextFormat} from "../../editor/text-format/FormatText";


/**
 * update the state of a text-format UI element to reflect the style of the current selection
 * @param frame
 * @param textFormat
 */
export function updateUiState(frame: HTMLIFrameElement, textFormat: ITextFormat)
{
    //  have we found a usable format? if not, stop here

    if ( ! textFormat) return;

    //  for each text format key present in the text format object,
    //  find all elements with the match data-format attribute and update them

    Object.keys(textFormat)
        .forEach(format => map(frame.contentDocument.body.querySelectorAll('[data-format=' + format + ']'),
            (uiElement: IInteractionTarget) => updateTextFormatControl(uiElement, format, textFormat[format])));
}


/**
 * update the state of a control
 * @param element
 * @param format
 * @param value
 */
function updateTextFormatControl(element: IInteractionTarget, format: string, value: boolean | string)
{
    switch (element.tagName)
    {
        case 'BUTTON':

            //  set the button's 'active' state, determined by whether its value matches the style of the selected text

            element.classList.toggle('active', value === getDataValueFromElement(element) || <boolean>value === true);

            // if the element has a data-label attribute, set its text to match the value

            if (element.dataset['label'] !== undefined) element.textContent = element.dataset['label'] + value;

            break;

        case 'INPUT':
        case 'SELECT':

            switch (format)
            {
                case KWILL_CONSTS.textFormats.LINE_HEIGHT:

                    return element.value = stripUnits(getStyleValueFromSelection(format));

                case KWILL_CONSTS.textFormats.LETTER_SPACING:

                    return element.value = stripUnits(getStyleValueFromSelection(format));

                default:

                    return element.value = <string>value;
            }
    }
}


/**
 * get a non-computed style for an element;
 * computed-style will convert values to px, but sometimes we want values as they actually are
 * @param style
 * @return {any}
 */
function getStyleValueFromSelection(style: string) : string
{
    let value: string;

    getTextNodesInRange().reverse().some(element =>
    {
        //  get the style value for this element

        value = getStyleFromElement(<HTMLElement>element, style);

        //  return the value

        return !! value;
    });

    //  return the value

    return value;
}


/**
 * get a non-computed style for an element;
 * computed-style will convert values to px, but sometimes we want values as they actually are
 * @param element
 * @param style
 * @returns {string}
 */
function getStyleFromElement(element: HTMLElement, style: string) : string
{
    try
    {
        let value: string;

        while (element)
        {
            //  get the style from the element

            value = element.style.getPropertyValue(style);

            //  if we've found a valid style, return it

            if (value) return value;

            //  otherwise, check the element's parent

            element = element.parentElement;
        }
    }
    catch (e) {}
}


/**
 * replace "normal" with a more useful (and consistent) value
 * @param value
 * @param substitute
 * @returns {string}
 */
function convertNormal(value: string, substitute: string) : string
{
    return value === 'normal' ? substitute : value;
}