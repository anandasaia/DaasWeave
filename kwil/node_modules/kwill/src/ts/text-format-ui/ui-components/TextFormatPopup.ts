import {getSignal} from "../../events/GlobalEvents";
import {KWILL_CONSTS} from "../../constants/Constants";
import {sniffFormats} from '../../editor/info/format-sniffer/FormatSniffer';
import {TextFormatUiBase} from './TextFormatUiBase';
import {closeAllColourPickers} from 'kulr';
import {getElementOffset} from '../../utils/dom/element/Offset';


export class TextFormatPopup extends TextFormatUiBase
{
    /**
     * add interaction listeners for a text format popup
     */
    addListeners()
    {
        //  add show/hide listeners for the popup

        getSignal(KWILL_CONSTS.events.SHOW_TEXT_FORMAT_POPUP).add((event: MouseEvent) => showTextFormatPopup(this.frame, event));
        getSignal(KWILL_CONSTS.events.HIDE_TEXT_FORMAT_POPUP).add(() => hideTextFormatPopup(this.frame));
        getSignal(KWILL_CONSTS.events.TEXT_FORMAT).add(() => focusTextFormatPopup(this.frame));


        // getGlobalSignal(kwillConstants.events.TEXT_FORMAT).dispatch(sniffFormats());

        //  add super class listeners

        super.addListeners();
    }
}


/**
 * populate and show the text format popup
 * @param frame
 * @param event
 */
function showTextFormatPopup(frame: HTMLIFrameElement, event: MouseEvent)
{
    //  update the UI to reflect the new text format

    getSignal(KWILL_CONSTS.events.TEXT_FORMAT).dispatch(sniffFormats());

    //  set format popup position

    translateTextFormatPopup(frame, event);

    //  show the text format popup

    frame.classList.add('visible');
}


/**
 * set the position of the popup
 * @param frame
 * @param event
 */
function translateTextFormatPopup(frame: HTMLIFrameElement, event: MouseEvent)
{
    //  set an arbitrary amount to offset the panel by to avoid overlapping the text

    const offset: number = 20;

    //  get the bounding rect for the text format element

    const bounds: ClientRect = getBounds(frame);

    //  test the position property of the frame; we'll need to treat it differently depending on whether it's absolute or fixed

    let mx: number,
        my: number;

    switch (window.getComputedStyle(frame).position)
    {
        case 'absolute':

            //  get the offset of the frame's parent element

            const elOffset: { top: number, left: number } = getElementOffset(<HTMLElement>frame.parentElement);


            //  adjust the mouse position by the offset

            mx = event.pageX - elOffset.left;
            my = event.pageY - elOffset.top;
            console.log('mouse position', event.pageX, event.pageY, elOffset)

            break;

        case 'fixed':

            mx = event.clientX;
            my = event.clientY;

            break;
    }

    //  calculate the position for the popup

    const x: number = mx + (event.clientX < window.innerWidth * 0.5 ? offset : -(bounds.width + offset));
    const y: number = my + (event.clientY < window.innerHeight * 0.5 ? offset : -(bounds.height + offset));

    //  transform the popup into position

    frame.style.setProperty('transform', 'translate(' + Math.round(x) + 'px,' + Math.round(y) + 'px)');
}


/**
 * get the popup element bounds
 * @param frame
 * @returns {ClientRect}
 */
function getBounds(frame: HTMLIFrameElement)
{
    let bounds: ClientRect;

    //  set some temporary properties on the frame; by default it's display: none
    //  so we need to show it in order to gets its size

    frame.style.setProperty('visibility', 'hidden');
    frame.style.setProperty('display', 'block');

    //  size the frame to match its contents

    frame.style.setProperty('width', frame.contentDocument.body.offsetWidth + 'px');
    frame.style.setProperty('height', frame.contentDocument.body.offsetHeight + 'px');

    //  get the bounding rect for the text format element

    bounds = frame.getBoundingClientRect();

    //  remove any styles we've added

    frame.style.setProperty('visibility', null);
    frame.style.setProperty('display', null);

    //  return the result

    return bounds;
}


/**
 * hide the text format popup
 * @param frame
 */
function hideTextFormatPopup(frame: HTMLIFrameElement)
{
    //  hide the popup

    frame.classList.remove('visible');

    //  close any open colour pickers

    closeAllColourPickers();
}


/**
 * focus the text format popup iframe; if we don't manually do this, the browser returns the focus to the selected text when formatting
 * @param frame
 */
function focusTextFormatPopup(frame: HTMLIFrameElement) : void
{
    frame.focus();
}