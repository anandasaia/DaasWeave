import {debounce} from "lodash";
import {findOne} from "../../utils/dom/element/Find";
import {captureElement} from "../FrameUtils";
import {onFormatUiBlur, onFormatUiFocus, onFormatUiInteraction, onTextFormatUiClick} from '../interactions/FormatInteractions';
import {updateUiState} from '../interactions/UpdateState';
import {KWILL_CONSTS} from '../../constants/Constants';
import {getSignal} from '../../events/GlobalEvents';
import {setupColourPicker} from './ColourPicker';
import {IKulrInstance} from 'kulr';
import {IKwillFormatUiOptions} from "../createTextFormatUi";
import {ITextFormat} from "../../editor/text-format/FormatText";


export class TextFormatUiBase
{
    frame: HTMLIFrameElement;
    colourPicker: IKulrInstance;

    constructor (public options: IKwillFormatUiOptions)
    {

    }


    /**
     * bootstrap the instance
     */
    bootstrap()
    {
        //  transpose the editor element into an iframe

        captureElement(findOne(this.options.popupSelector), this.options, iframe => this.onFrameReady(iframe));
    }


    /**
     * when the frame is ready, populate it
     * @param iframe
     */
    onFrameReady(iframe: HTMLIFrameElement)
    {
        //  save the reference to the frame element

        this.frame = iframe;

            //  add interaction listeners

        this.addListeners();

        //  setup the colour picker

        this.setupColourPicker();
    }


    /**
     * add interaction listeners to the framed format UI
     */
    addListeners()
    {
        //  set up interaction listeners

        this.frame.contentDocument.addEventListener('mouseup', onTextFormatUiClick);
        this.frame.contentDocument.addEventListener('focus', onFormatUiFocus);
        this.frame.contentDocument.addEventListener('blur', onFormatUiBlur);
        this.frame.contentDocument.addEventListener('input', debounce(onFormatUiInteraction, 500));

        //  listen for text formats events; when we receive one, update the UI state to match the format

        getSignal(KWILL_CONSTS.events.TEXT_FORMAT).add((textFormat: ITextFormat) => updateUiState(this.frame, textFormat));
    }


    /**
     * set up the colour picker for this format UI
     */
    setupColourPicker()
    {
        //  attempt to set up a colour picker

        const colourPicker: IKulrInstance = setupColourPicker(this.frame, this.options);

        //  if the colour picker can't be created, stop here

        if ( ! colourPicker) return;

        //  when the text format changes, update the colour picker's selected colour

        getSignal(KWILL_CONSTS.events.TEXT_FORMAT).add((textFormat: ITextFormat) => colourPicker.setColour(textFormat.color));

        //  save a reference to the colour picker

        this.colourPicker = colourPicker;
    }


    /**
     * destroy the instance
     */
    destroy()
    {
        //  remove the frame element from the page

        this.frame.parentElement.removeChild(this.frame);

        //  destroy the colour picker if one exists

        try
        {
            this.colourPicker.destroy();
        }
        catch(e) {}
    }
}