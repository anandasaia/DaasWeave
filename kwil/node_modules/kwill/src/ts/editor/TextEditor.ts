import * as log from 'loglevel';
import {forIn} from 'lodash';
import {findOne} from "../utils/dom/element/Find";
import {addTextElementListeners, removeTextElementListeners} from "./interaction/Interaction";
import {isEditorSelectorValid} from '../options/ValidateOptions';
import {getRange} from "../utils/dom/html/range/Range";
import {IKwillInstanceOptions} from "./createKwillEditor";

var instances: any,
    activeInstanceID: string;

export class TextEditor
{
    element: HTMLElement;

    constructor(public instanceID: string, public options: IKwillInstanceOptions)
    {

    }


    /**
     * set up the text editing pane
     */
    bootstrap()
    {
        //  find and save the editor's target element

        this.element = findOne(this.options.selector);

        //  add some extra properties to the element

        //  add default content to the editable element

        this.setDefaultContent();
        this.setDefaultStyles();

        //  add event listeners for this instance

        addTextElementListeners(this.instanceID);
    }


    /**
     * set default styles, attributes and content
     */
    setDefaultContent()
    {
        try
        {
            let defaultContent: string;

            //  get default content from the options

            defaultContent = this.options.content.defaultHtml;

            //  if there is any default content, set it

            if (defaultContent) this.content = this.options.content.defaultHtml;
        }
        catch(e) {}
    }


    /**
     * set default styles and attributes on the editable element
     */
    setDefaultStyles()
    {
        //  make the element editable

        this.element.setAttribute('contenteditable', 'true');

        //  add some extra styles to the element

        this.element.style.outline = 'none';
        this.element.style.textAlign = <string>this.options.style.textAlign;
        this.element.style.lineHeight = <string>this.options.style.lineHeight;
        this.element.style.letterSpacing = <string>this.options.style.letterSpacing;
    }


    /**
     * get the text pane's content as a node
     * @return {HTMLParagraphElement}
     */
    getActiveParagraph() : HTMLParagraphElement
    {
        let range: Range,
            element: HTMLElement;

        //  get the current range

        range = getRange();

        element = <HTMLElement>range.startContainer;

        while (element && element.tagName !== 'P')
        {
            element = element.parentElement;
        }

        //  return the active paragraph element

        return <HTMLParagraphElement>element;
    }


    /**
     * get the element width
     * @returns {number}
     */
    get width() : number
    {
        return this.element.offsetWidth;
    }


    /**
     * get the element height
     * @returns {number}
     */
    get height() : number
    {
        return this.element.offsetHeight;
    }


    /**
     * get the text pane's content as a node
     */
    get paragraphs(): NodeListOf<HTMLParagraphElement>
    {
        return this.element.getElementsByTagName('p');
    }


    /**
     * get the content of the editable element
     * @return {string}
     */
    get content() : string
    {
        return this.element.innerHTML;
    }

    /**
     * set the editable element content
     * @param content
     */
    set content(content: string)
    {
        this.element.innerHTML = content;
    }


    /**
     * destroy this editor instance
     */
    destroy()
    {
        //  destroy text pane and restore starting content

        removeTextElementListeners(this.instanceID);

        //  make the element non-editable

        this.element.setAttribute('contenteditable', null);
    }
}


/**
 * create a new editor instance instance
 * @param instanceID
 * @param options
 * @return {TextEditor}
 */
export function createTextEditor(instanceID: string, options: IKwillInstanceOptions) : TextEditor
{
    let instance: TextEditor;

    //  test whether we have a valid target element

    if ( ! isEditorSelectorValid(options)) return;

    //  create a new editor instance instance

    instance = new TextEditor(instanceID, options);

    //  save the new instance

    saveInstance(instanceID, instance);

    //  bootstrap the instance

    instance.bootstrap();

    //  return the new instance

    return instance;
}


/**
 * save, retrieve and clear the active instance ID
 */
export let setActiveTextEditorID: (instanceID: string) => void = instanceID => activeInstanceID = instanceID;
export let getActiveTextEditorID: () => string = () => activeInstanceID;
export let getActiveTextEditor: () => TextEditor = () => getTextEditor(getActiveTextEditorID());
export let clearActiveTextEditorID: () => void = () => activeInstanceID = null;


/**
 * retrieve a editor instance by instanceID
 * @param id
 */
export function getTextEditor(id: string) : TextEditor
{
    return getInstances()[id];
}


/**
 * retrieve a editor instance by instanceID
 * @return {any}
 */
export function getAllTextEditors() : any
{
    return getInstances();
}


/**
 * destroy a editor instance by instanceID
 * @param id
 */
export function destroyTextEditor(id: string)
{
    //  find an instance and destroy it

    getTextEditor(id).destroy();

    //  then remove the reference to it

    delete instances[id];
}


/**
 * destroy all editor instances
 */
export function destroyAllTextEditors()
{
    forIn(instances, (instance: TextEditor, id: string) => destroyTextEditor(id));
}


/**
 * save a new instance of this class
 * @param instance
 * @param id
 */
function saveInstance(id: string, instance: TextEditor)
{
    getInstances()[id] = instance;
}


/**
 * get the instances dictionary
 * @returns {any|{}}
 */
function getInstances() : any
{
    return instances || (instances = {});
}