import * as log from 'loglevel';
import {getEditorElement} from '../EditorInstanceUtils';
import {getSignal} from '../../events/GlobalEvents';
import {stopUserDeletingEditableElement} from '../utils/PreventContentDeletion';
import {clearSignalBindings} from './SignalBindingsManager';
import {startTrackingEdits, trackEdits} from '../track-changes/TrackChanges';
import {KWILL_CONSTS} from '../../constants/Constants';
import {getActiveTextEditor, setActiveTextEditorID} from "../TextEditor";


/**
 * listen to text pane interactions events
 * @param instanceID
 */
export function addTextElementListeners(instanceID: string)
{
    let textElement: HTMLElement;

    //  get the text pane for this instanceID

    textElement = getEditorElement(instanceID);

    //  add local listeners

    // textElement.addEventListener('focus', (event: MouseEvent) => onFocus(instanceID, event));
    textElement.addEventListener('mousedown', (event: MouseEvent) => onSelectionStart(instanceID, event));
    textElement.addEventListener('keydown', (event: KeyboardEvent) => onInstanceKeyDown(instanceID, event));
    textElement.addEventListener('input', () => onContentInput(instanceID));
}


/**
 * when the user presses the mouse down within an editor instance
 * @param instanceID
 * @param mouseEvent
 */
function onFocus(instanceID: string, mouseEvent: MouseEvent)
{
    //  set active editor ID

    setActiveTextEditorID(instanceID);

    //  start tracking changes in the selected instances

    startTrackingEdits(instanceID);
}


/**
 * when the user starts to select text, start listening for mouse-up and key-up events to determine when the user has finished their selection
 * @param mouseEvent
 * @param instanceID
 */
let onSelectionStart = (instanceID: string, mouseEvent: MouseEvent) =>
{
    //  artficially trigger the focus event; using the actual browser event meant it was triggered accidentally by the refocus when we format text

    onFocus(instanceID, mouseEvent);

    //  get the text pane for this instanceID

    const textElement: HTMLElement = getEditorElement(instanceID);

    //  start listening for selection-end events

    textElement.addEventListener('keyup', onSelectionEnd);
    document.addEventListener('mouseup', onSelectionEnd);
};


/**
 * when the content of an editor instance is updated
 * @param instanceID
 */
function onContentInput(instanceID: string)
{
    //  flag that content has changed

    trackEdits(instanceID);
}


/**
 * when the selection is complete
 * @param mouseEvent
 */
let onSelectionEnd = (mouseEvent: MouseEvent | KeyboardEvent) =>
{
    //  get the text pane for this instanceID

    const textElement: HTMLElement = getActiveTextEditor().element;

    //  stop listening for selection end events

    textElement.removeEventListener('keyup', onSelectionEnd);
    document.removeEventListener('mouseup', onSelectionEnd);

    //  add a short delay to let the selection in the page clear if necessary

    setTimeout(() =>
    {
        //  has anything been selected? if not, stop here

        if (window.getSelection().isCollapsed) return;

        //  if we have a valid selection, show the text edit popup

        getSignal(KWILL_CONSTS.events.SHOW_TEXT_FORMAT_POPUP).dispatch(mouseEvent);
    }, 10);
};


/**
 * when the user presses a keyboard button down within the editor
 * @param instanceID
 * @param keyboardEvent
 */
function onInstanceKeyDown(instanceID: string, keyboardEvent: KeyboardEvent)
{
    stopUserDeletingEditableElement(instanceID, keyboardEvent);
}


/**
 * remove all text pane listeners
 * @param instanceID
 */
export function removeTextElementListeners(instanceID: string)
{
    //  clear all signal bindings

    clearSignalBindings(instanceID);

    //  get the text pane for this instanceID

    const textElement: HTMLElement = getEditorElement(instanceID);

    //  get the parent element

    const parentElement: HTMLElement = textElement.parentElement;

    //  clone the text element and replace the original; this removes all listeners

    parentElement.replaceChild(textElement.cloneNode(true), textElement);
}