import * as log from 'loglevel';
import {removeAttributes} from '../../../utils/dom/html/RemoveAttributes';
import {getNodesInRange, getBlockLevelNodesInRange} from "../../../utils/dom/html/range/GetNodesInRange";

/**
 * set a specific style on the current selection
 * @param styleName
 * @param value
 */
export function styleSelection(styleName: string, value: any)
{
    //  setting arbitrary CSS on elements is a bit tricky,
    //  so this is slightly hacky (but seems to work pretty reliably)

    //  document.execCommand only lets us set some properties, and some values;
    //  eg font sizes 1-7, but not px sizes

    //  we're going to let execCommand create a font tag for us,
    //  (it'll handle inconvenient things like overlapping font tags for us)
    //  but then we'll manually find each tag that has been created
    //  and replace the basic "size" attribute with the CSS style we want

    // console.log('setting style:', styleName, value);


    //  apply a size attribute to the current selection

    document.execCommand('fontSize', false, 4);

    //  get all nodes in the currently selected range, filter to find any with a size tag, and remove the tag

    removeAttributes(getNodesInRange(), 'size')
        .map((node: HTMLElement) => node.style.setProperty(styleName, value));


    //TODO  various failed attempts below to allow more complex style mixing
    //  currently we apply letter-spacing (and would do the same for other similar styles) to block-level elements rather then per word -
    //  applying per-word involves analysing and breaking up existing inline elements and is hard


    // document.execCommand('fontSize', false, 4);
    //
    // //  get all nodes in the currently selected range, filter to find any with a size tag, and remove the tag
    //
    // //  find all span tags in the current selection and remove the given style from them
    //
    // let spans: HTMLSpanElement[];
    //
    //
    // if (styleName === kwillConstants.textFormats.LETTER_SPACING ) return;
    //
    // getTagsInRange(['SPAN']).forEach(element => element.style.setProperty(styleName, null));
    //
    //
    // spans = getTagsInRange(['FONT']).map(node =>
    // {
    //     let replacement: HTMLElement;
    //
    //     replacement = document.createElement('span');
    //     replacement.innerHTML = node.innerHTML;
    //     replacement.style.setProperty(styleName, value);
    //
    //     node.parentElement.replaceChild(replacement, node);
    //
    //     return replacement;
    // });
    //
    // setTimeout(() =>
    // {
    //     let range: Range = new Range();
    //
    //     range.setStartBefore(spans[0]);
    //     range.setEndAfter(spans[spans.length-1]);
    //
    //     window.getSelection().addRange(range);
    //
    //     getTagsInRange(['SPAN']).forEach(element => element.style.setProperty(styleName, value));
    //
    //     console.log(getTagsInRange(['SPAN']))
    // }, 40);



    // switch (styleName)
    // {
    //     case kwillConstants.textFormats.LETTER_SPACING:
    //
    //         //  apply a size attribute to the current selection; let's let the browser do the hard work
    //
    //         document.execCommand('fontSize', false, 4);
    //
    //         //  get all nodes in the currently selected range, filter to find any with a size tag, and remove the tag
    //
    //         //  find all span tags in the current selection and remove the given style from them
    //
    //         let spans: HTMLSpanElement[];
    //
    //         getTagsInRange(['SPAN']).forEach(element => element.style.setProperty(styleName, null));
    //
    //
    //         spans = getTagsInRange(['FONT']).map(node =>
    //         {
    //             let replacement: HTMLElement;
    //
    //             replacement = document.createElement('span');
    //             replacement.innerHTML = node.innerHTML;
    //             replacement.style.setProperty(styleName, value);
    //
    //             node.parentElement.replaceChild(replacement, node);
    //
    //             return replacement;
    //         });
    //
    //         setTimeout(() =>
    //         {
    //             let range: Range = new Range();
    //
    //             range.setStartBefore(spans[0]);
    //             range.setEndAfter(spans[spans.length-1]);
    //
    //             window.getSelection().addRange(range);
    //
    //             getTagsInRange(['SPAN']).forEach(element => element.style.setProperty(styleName, value));
    //
    //             console.log(getTagsInRange(['SPAN']))
    //         }, 40);
    //
    //
    //
    //
    //         // document.getSelection().addRange();
    //
    //         // console.log(getFormattingNodesInRange());
    //
    //         // removeAttributes(getNodesInRange(), 'size')
    //         //     .map((node: HTMLElement) => node.style.setProperty(styleName, value));
    //
    //         break;
    //
    //     case kwillConstants.textFormats.FONT_SIZE:
    //
    //         //  apply a size attribute to the current selection
    //
    //         document.execCommand('fontSize', false, 4);
    //
    //         //  get all nodes in the currently selected range, filter to find any with a size tag, and remove the tag
    //
    //         removeAttributes(getNodesInRange(), 'size')
    //             .map((node: HTMLElement) => node.style.setProperty(styleName, value));
    //
    //         break;
    // }

    //  get the active editor instanceID



    // getTextNodesInRange().forEach(node =>
    // {
    //     document.execCommand('styleWithCSS', )
    // })


    // document.execCommand("insertHTML", false, "<span style='font-size: " + value + ";'>"+ document.getSelection()+"</span>");

}


/**
 * set a specific style on the current group
 * @param styleName
 * @param value
 */
export function styleGroup(styleName: string, value: string)
{
    //  get all main nodes in the range, filter the list of nodes to get only <p> and <img> elements, then apply the style

    getBlockLevelNodesInRange().map((node: HTMLElement) => node.style.setProperty(styleName, value));
}