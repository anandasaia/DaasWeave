import * as log from 'loglevel';
import {getRange, restoreSelection, saveSelection} from "../../../utils/dom/html/range/Range";
import {KWILL_CONSTS} from "../../../constants/Constants";
import {ITextFormat} from "../../text-format/FormatText";

let cachedComputedStyle: CSSStyleDeclaration;


/**
 * sniff all styles and formats for the current selection
 * @return {ITextFormat}
 */
export function sniffFormats() : ITextFormat
{
    try
    {
        //  parse and save the computed style for the current selection

        cachedComputedStyle = getComputedStyleForSelection();
    }
    catch(e)
    {
        log.warn('nothing selected');
    }

    let format: ITextFormat;

    //  test properties of the computed style

    format =
        {
            'bold': sniffStyle('bold'),
            'italic': sniffStyle('italic'),
            'underline': sniffStyle('underline'),
            'strikethrough': sniffStyle('strikethrough'),
            'font-size': sniffNumericFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.FONT_SIZE),
            'font-family': sniffFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.FONT_FAMILY),
            'color': sniffFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.TEXT_COLOUR),
            'text-align': sniffFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.TEXT_ALIGN),
            'line-height': sniffFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.LINE_HEIGHT),
            'letter-spacing': sniffFormat(cachedComputedStyle, KWILL_CONSTS.textFormats.LETTER_SPACING),
            link: sniffHref()
        };

    return format;
}


/**
 * calculate the computed style for the current selection
 * @returns {CSSStyleDeclaration}
 */
export function getComputedStyleForSelection() : CSSStyleDeclaration
{
    return window.getComputedStyle(getFirstSelectedElement());
}


/**
 * detect various formats in the current selection
 * @param style
 * @return {any}
 */
export function sniffStyle(style: string) : any
{
    let result: any;

    //  save the current selection

    saveSelection();

    //  turn design mode on; this clears the current selection in Edge

    document.designMode = "on";

    //  restore the selection

    restoreSelection();

    //  test the value for the selected element(s)

    switch (style)
    {
        case 'bold':

            result = document.queryCommandState('Bold');

            break;

        case 'italic':

            result = document.queryCommandState('Italic');

            break;

        case 'underline':

            result = document.queryCommandState('Underline');

            break;

        case 'strikethrough':

            result = document.queryCommandState('Strikethrough');

            break;
    }

    //  save the current selection

    saveSelection();

    //  turn design mode off again

    document.designMode = "off";

    //  restore the selection

    restoreSelection();

    //  return the result

    return result;
}


/**
 * extract a style from the computed style object
 * @param computedStyle
 * @param format
 * @returns {string}
 */
function sniffFormat(computedStyle: CSSStyleDeclaration, format: string) : string
{
    return computedStyle.getPropertyValue(format);
}


/**
 * extract a style from the computed style object and return as a number
 * @param computedStyle
 * @param format
 * @returns {string}
 */
function sniffNumericFormat(computedStyle: CSSStyleDeclaration, format: string) : number
{
    return parseInt(computedStyle.getPropertyValue(format));
}


/**
 * find the href attribute of the element (or a parent element)
 * @returns {CSSStyleDeclaration}
 */
function sniffHref() : string
{
    return getFirstSelectedElement().getAttribute('href');
}


/**
 * find the first valid element in a selection
 * @returns {HTMLElement}
 */
function getFirstSelectedElement() : HTMLElement
{
    //  find the first valid element in the selection

    let element: HTMLElement = <HTMLElement>getRange().endContainer;

    //  move back up the document tree until we find a valid element

    while (element.nodeType !== 1)
    {
        element = element.parentElement;
    }

    return element;
}