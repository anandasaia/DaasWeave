import * as log from 'loglevel';
import {forIn} from 'lodash';
import {KWILL_CONSTS} from "../../constants/Constants";
import {getSignal} from "../../events/GlobalEvents";
import {getTextEditor} from "../TextEditor";

export interface IInstanceStateDictionary
{
    [id: string]: IKwillInstanceState
}

export interface IKwillInstanceState
{
    id: string;
    contentHasChanged: boolean;
    startHeight: number;
    endHeight?: number;
}


let contentChangeDelay: number,
    contentChangeFlags: IInstanceStateDictionary;



/**
 * when the user makes changes to the contents of a field, flag that something has changed
 * @param instanceID
 */
export function startTrackingEdits(instanceID: string)
{
    let instanceState: IKwillInstanceState;

    //  snapshot the current instance state

    instanceState =
        {
            id: instanceID,
            contentHasChanged: false,
            startHeight: getInstanceHeight(instanceID)
        };

    //  and save it

    setInstanceState(instanceID, instanceState);
}


/**
 * when the user makes changes to the contents of a field, flag that something has changed
 * @param instanceID
 */
export function trackEdits(instanceID: string)
{
    //TODO  use lodash debounce

    //  flag that the user has input something to the instance

    getInstanceState(instanceID).contentHasChanged = true;

    //  clear the current timeout, if it exists

    if (contentChangeDelay) clearTimeout(contentChangeDelay);

    //  dispatch an edit-in-progress event after a short delay

    contentChangeDelay = window.setTimeout(() => getSignal(KWILL_CONSTS.events.EDIT_PROGRESS).dispatch(getInstanceState(instanceID)), 1000);
}


/**
 * when the user makes changes to the contents of a field, flag that something has changed
 */
export function stopTrackingEdits()
{
    //  clear the edit-progress timeout

    if (contentChangeDelay) clearTimeout(contentChangeDelay);



    //  check whether any instances have been changed

    forIn(getContentStateDictionary(), (instanceState: IKwillInstanceState, instanceID: string) =>
    {
        try
        {
            //  for each instance, check whether it has tracked any changes

            if (instanceState.contentHasChanged === true)
            {
                // console.log('stopTrackingEdits', instanceID, instanceState.contentHasChanged, instanceState.startHeight, getInstanceHeight(instanceID));

                //  check and save the new height of the instance; has it changed from when we started editing?

                instanceState.endHeight = getInstanceHeight(instanceID);

                //  if something has changed, dispatch a signal with the affected instance's instanceID

                getSignal(KWILL_CONSTS.events.EDIT_COMPLETE).dispatch(instanceState);

                //  and clear the change flag

                instanceState.contentHasChanged = false;
            }
        }
        catch(e)
        {
            //log.debug('no changes for instance ', instanceID);
        }
    });
}


/**
 * get the height of an editor instancew
 * @param instanceID
 * @return {number}
 */
function getInstanceHeight(instanceID: string) : number
{
    return getTextEditor(instanceID).height;
}



/**
 * get an instance state object
 * @param instanceID
 * @returns {IKwillInstanceState}
 */
function getInstanceState(instanceID: string) : IKwillInstanceState
{
    return getContentStateDictionary()[instanceID];
}


/**
 * get an instance state object
 * @param instanceID
 * @param instanceState
 */
function setInstanceState(instanceID: string, instanceState: IKwillInstanceState)
{
    getContentStateDictionary()[instanceID] = instanceState;
}


/**
 * get the dictionary object for instance state tracking
 * @returns {IInstanceStateDictionary|{}}
 */
function getContentStateDictionary() : IInstanceStateDictionary
{
    return contentChangeFlags || (contentChangeFlags = {});
}
