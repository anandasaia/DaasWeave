"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionBuilderImpl = void 0;
const tx_1 = require("../core/tx");
const objects_1 = require("../utils/objects");
const types_1 = require("../utils/types");
const transaction_builder_1 = require("./transaction_builder");
const actionInput_1 = require("../core/actionInput");
const TXN_BUILD_IN_PROGRESS = [];
/**
 * `ActionBuilderImpl` class is an implementation of the `ActionBuilder` interface.
 * It helps in building and transactions to execute database actions on the Kwil network.
 */
class ActionBuilderImpl {
    constructor(client) {
        this._signer = null;
        this._actions = [];
        this.client = objects_1.objects.requireNonNil(client);
    }
    static of(client) {
        return new ActionBuilderImpl(client);
    }
    name(actionName) {
        this.assertNotBuilding();
        this._name = objects_1.objects.requireNonNil(actionName.toLowerCase());
        return this;
    }
    dbid(dbid) {
        this.assertNotBuilding();
        this._dbid = objects_1.objects.requireNonNil(dbid);
        return this;
    }
    signer(signer) {
        this.assertNotBuilding();
        this._signer = objects_1.objects.requireNonNil(signer);
        return this;
    }
    concat(actions) {
        this.assertNotBuilding();
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        for (const action of actions) {
            this._actions.push(objects_1.objects.requireNonNil(action));
        }
        return this;
    }
    buildTx() {
        return __awaiter(this, void 0, void 0, function* () {
            this.assertNotBuilding();
            const cached = objects_1.objects.requireNonNil(this._actions);
            this._actions = TXN_BUILD_IN_PROGRESS;
            return yield this
                .dobuildTx(cached)
                .finally(() => this._actions = cached);
        });
    }
    dobuildTx(actions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const dbid = objects_1.objects.requireNonNil(this._dbid);
            const name = objects_1.objects.requireNonNil(this._name);
            const signer = yield types_1.Promisy.resolveOrReject(this._signer);
            const schema = yield this.client.getSchema(dbid);
            if (!((_a = schema === null || schema === void 0 ? void 0 : schema.data) === null || _a === void 0 ? void 0 : _a.actions)) {
                throw new Error(`Could not retrieve actions for database ${dbid}. Please double check that you have the correct DBID.`);
            }
            const actionSchema = schema.data.actions.find((act) => act.name == name);
            if (!actionSchema) {
                throw new Error(`Could not find action ${name} in database ${dbid}. Please double check that you have the correct DBID and action name.`);
            }
            const preparedActions = this.prepareActions(actions, actionSchema, name);
            const payload = {
                "action": name,
                "dbid": dbid,
                "params": preparedActions
            };
            return transaction_builder_1.TxnBuilderImpl
                .of(this.client)
                .payloadType(tx_1.PayloadType.EXECUTE_ACTION)
                .payload(payload)
                .signer(signer)
                .build();
        });
    }
    prepareActions(actions, actionSchema, actionName) {
        if ((!actionSchema.inputs || actionSchema.inputs.length === 0) && actions.length === 0) {
            return [];
        }
        if (!actionSchema.inputs) {
            throw new Error(`No inputs found for action schema: ${actionName}.`);
        }
        if (actions.length == 0) {
            throw new Error("No action data has been added to the ActionBuilder.");
        }
        const missingActions = new Set();
        actionSchema.inputs.forEach((i) => {
            const found = actions.find((a) => a.containsKey(i));
            if (!found) {
                missingActions.add(i);
            }
        });
        if (missingActions.size > 0) {
            throw new Error(`Actions do not match action schema inputs: ${Array.from(missingActions)}`);
        }
        const preparedActions = [];
        const missingInputs = new Set();
        actions.forEach((a) => {
            const copy = actionInput_1.ActionInput.from(a);
            actionSchema.inputs.forEach((i) => {
                if (missingInputs.has(i)) {
                    return;
                }
                if (!copy.containsKey(i)) {
                    missingInputs.add(i);
                    return;
                }
                if (missingInputs.size > 0) {
                    return;
                }
                const val = copy.get(i);
                copy.put(i, val);
            });
            if (missingInputs.size === 0) {
                preparedActions.push(copy);
            }
        });
        if (missingInputs.size > 0) {
            throw new Error(`Inputs are missing for actions: ${Array.from(missingInputs)}`);
        }
        return preparedActions;
    }
    assertNotBuilding() {
        if (this._actions === TXN_BUILD_IN_PROGRESS) {
            throw new Error("Cannot modify the builder while a transaction is being built.");
        }
    }
}
exports.ActionBuilderImpl = ActionBuilderImpl;
//# sourceMappingURL=action_builder.js.map