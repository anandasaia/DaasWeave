"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxnBuilderImpl = void 0;
const types_1 = require("../utils/types");
const objects_1 = require("../utils/objects");
const bytes_1 = require("../utils/bytes");
const strings_1 = require("../utils/strings");
const tx_1 = require("../core/tx");
const crypto_1 = require("../utils/crypto");
const base64_1 = require("../utils/base64");
const intern_1 = require("../client/intern");
class TxnBuilderImpl {
    constructor(client) {
        this._payloadType = null;
        this._payload = null;
        this._signer = null;
        this.client = objects_1.objects.requireNonNil(client);
    }
    payloadType(payloadType) {
        this._payloadType = objects_1.objects.requireNonNil(payloadType);
        return this;
    }
    static of(client) {
        return new TxnBuilderImpl(client);
    }
    signer(signer) {
        this._signer = objects_1.objects.requireNonNil(signer);
        return this;
    }
    payload(payload) {
        this._payload = typeof objects_1.objects.requireNonNil(payload) !== "function" ?
            () => payload :
            payload;
        return this;
    }
    build() {
        return __awaiter(this, void 0, void 0, function* () {
            objects_1.objects.requireNonNil(this.client);
            const payloadFn = objects_1.objects.requireNonNil(this._payload);
            const payloadType = objects_1.objects.requireNonNil(this._payloadType);
            const signer = yield types_1.Promisy.resolveOrReject(this._signer);
            const sender = (yield signer.getAddress()).toLowerCase();
            const acct = yield this.client.getAccount(sender);
            if (acct.status !== 200 || !acct.data) {
                throw new Error(`Could not retrieve account ${sender}. Please double check that you have the correct account address.`);
            }
            const json = objects_1.objects.requireNonNil(payloadFn());
            const preEstTxn = tx_1.Txn.create(tx => {
                tx.sender = sender;
                tx.payload = (0, bytes_1.MarshalB64)(json);
                tx.payload_type = payloadType;
            });
            const cost = yield (0, intern_1.unwrap)(this.client)(preEstTxn);
            if (cost.status !== 200 || !cost.data) {
                throw new Error(`Could not retrieve cost for transaction. Please double check that you have the correct account address.`);
            }
            const postEstTxn = tx_1.Txn.copy(preEstTxn, tx => {
                var _a;
                tx.fee = strings_1.strings.requireNonNil(cost.data);
                tx.nonce = Number(objects_1.objects.requireNonNil((_a = acct.data) === null || _a === void 0 ? void 0 : _a.nonce)) + 1;
            });
            return TxnBuilderImpl.sign(postEstTxn, signer);
        });
    }
    static sign(tx, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = TxnBuilderImpl.hash_txn(tx);
            const signature = yield (0, crypto_1.sign)(hash, signer);
            const sender = yield signer.getAddress();
            return tx_1.Txn.copy(tx, (tx) => {
                tx.signature = signature;
                tx.sender = sender;
                tx.hash = hash;
            });
        });
    }
    static hash_txn(tx) {
        const payloadType = (0, bytes_1.NumberToUint32LittleEndian)(tx.payload_type);
        const payloadHash = (0, crypto_1.sha384BytesToBytes)((0, base64_1.base64ToBytes)(tx.payload));
        const fee = (0, bytes_1.StringToUint8LittleEndian)(tx.fee);
        const nonce = (0, bytes_1.NumberToUint64LittleEndian)(tx.nonce);
        const hash = (0, crypto_1.sha384BytesToBytes)((0, bytes_1.ConcatBytes)(payloadType, payloadHash, fee, nonce));
        return (0, base64_1.bytesToBase64)(hash);
    }
}
exports.TxnBuilderImpl = TxnBuilderImpl;
//# sourceMappingURL=transaction_builder.js.map