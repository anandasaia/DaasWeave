"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Funder = void 0;
const ethers_1 = require("ethers");
const escrowV6_1 = require("./escrowV6");
const tokenV6_1 = require("./tokenV6");
const erc20HumanAbi_1 = __importDefault(require("./abi/erc20HumanAbi"));
const kwilHumanAbi_1 = __importDefault(require("./abi/kwilHumanAbi"));
const ethers5_1 = require("ethers5");
const crypto_1 = require("../utils/crypto");
const escrowV5_1 = require("./escrowV5");
const TokenV5_1 = require("./TokenV5");
/**
 * `Funder` class helps manage the funding process for a user's account on Kwil.
 */
class Funder {
    constructor(signer, config) {
        this.poolAddress = config.pool_address;
        this.signer = signer;
        this.providerAddress = config.provider_address;
    }
    static create(signer, config) {
        return __awaiter(this, void 0, void 0, function* () {
            const funder = new Funder(signer, config);
            if (!(0, crypto_1.isV5Signer)(signer) || signer instanceof ethers_1.ethers.Wallet) {
                funder.escrowContract = new escrowV6_1.EscrowV6(funder.providerAddress, funder.poolAddress, kwilHumanAbi_1.default, signer);
                let tokenAddress = yield funder.escrowContract.getTokenAddress();
                funder.erc20Contract = new tokenV6_1.TokenV6(tokenAddress, erc20HumanAbi_1.default, signer);
            }
            if ((0, crypto_1.isV5Signer)(signer) || signer instanceof ethers5_1.Wallet) {
                funder.escrowContract = new escrowV5_1.EscrowV5(funder.providerAddress, funder.poolAddress, kwilHumanAbi_1.default, signer);
                let tokenAddress = yield funder.escrowContract.getTokenAddress();
                funder.erc20Contract = new TokenV5_1.TokenV5(tokenAddress, erc20HumanAbi_1.default, signer);
            }
            return funder;
        });
    }
    /**
     * Retrieves the token allowance for a particular address.
     *
     * @param address - The address to check the allowance for.
     * @returns A promise that resolves to the allowance result.
     */
    getAllowance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.erc20Contract) {
                throw new Error("Funder not initialized");
            }
            const res = yield this.erc20Contract.getAllowance(address, this.poolAddress);
            const num = BigInt(res);
            return {
                allowance_balance: num.toString(),
            };
        });
    }
    /**
     * Retrieves the wallet token balance for a particular address. The token is the token used for funding on the configured Kwil provider.
     *
     * @param address - The address to check the balance for.
     * @returns A promise that resolves to the wallet token balance.
     */
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.erc20Contract) {
                throw new Error("Funder not initialized");
            }
            const res = yield this.erc20Contract.getBalance(address);
            const num = BigInt(res);
            return {
                balance: num.toString(),
            };
        });
    }
    /**
    * Approves / set allowance for a certain amount of tokens for transfer.
    *
    * @param amount - The amount to approve for transfer.
    * @returns A promise that resolves to the transaction response.
    */
    approve(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.erc20Contract) {
                throw new Error("Funder not initialized");
            }
            return yield this.erc20Contract.approve(this.poolAddress, amount);
        });
    }
    /**
     * Deposits a certain amount of tokens. Funds must be approved before depositing.
     *
     * @param amount - The amount to deposit.
     * @returns A promise that resolves to the transaction response.
     */
    deposit(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.escrowContract) {
                throw new Error("Funder not initialized");
            }
            return yield this.escrowContract.deposit(amount);
        });
    }
    /**
     * Retrieves the deposited balance for a particular address.
     *
     * @param address - The address to check the deposited balance for.
     * @returns A promise that resolves to the deposited balance result.
     */
    getDepositedBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.escrowContract) {
                throw new Error("Funder not initialized");
            }
            const res = yield this.escrowContract.getDepositedBalance(address);
            const num = BigInt(res);
            return {
                deposited_balance: num.toString(),
            };
        });
    }
    /**
     * Retrieves the address of the token contract for the configured Kwil provider.
     *
     * @returns A promise that resolves to the token address result.
     */
    getTokenAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.escrowContract) {
                throw new Error("Funder not initialized");
            }
            const res = yield this.escrowContract.getTokenAddress();
            return {
                token_address: res,
            };
        });
    }
}
exports.Funder = Funder;
//# sourceMappingURL=funding.js.map