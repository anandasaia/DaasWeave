"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Txn = exports.Transaction = exports.PayloadType = void 0;
const signature_1 = require("./signature");
const strings_1 = require("../utils/strings");
var PayloadType;
(function (PayloadType) {
    PayloadType[PayloadType["INVALID_PAYLOAD_TYPE"] = 100] = "INVALID_PAYLOAD_TYPE";
    PayloadType[PayloadType["DEPLOY_DATABASE"] = 101] = "DEPLOY_DATABASE";
    PayloadType[PayloadType["MODIFY_DATABASE"] = 102] = "MODIFY_DATABASE";
    PayloadType[PayloadType["DROP_DATABASE"] = 103] = "DROP_DATABASE";
    PayloadType[PayloadType["EXECUTE_ACTION"] = 104] = "EXECUTE_ACTION";
})(PayloadType || (exports.PayloadType = PayloadType = {}));
class Transaction {
    constructor(data) {
        this.data = data || {
            hash: "",
            payload_type: PayloadType.EXECUTE_ACTION,
            payload: "",
            fee: "0",
            nonce: -1,
            signature: {
                signature_bytes: "",
                signature_type: signature_1.SignatureType.ACCOUNT_SECP256K1_UNCOMPRESSED
            },
            sender: "",
        };
    }
    isSigned() {
        return !strings_1.strings.isNilOrEmpty(this.data.signature.signature_bytes);
    }
    get hash() {
        return this.data.hash;
    }
    get payload_type() {
        return this.data.payload_type;
    }
    get payload() {
        return this.data.payload;
    }
    get fee() {
        return this.data.fee;
    }
    get nonce() {
        return this.data.nonce;
    }
    get signature() {
        return this.data.signature;
    }
    get sender() {
        return this.data.sender;
    }
    // noinspection JSUnusedLocalSymbols
    toJSON() {
        return this.data;
    }
}
exports.Transaction = Transaction;
var Txn;
(function (Txn) {
    function create(configure) {
        const tx = {
            hash: "",
            payload_type: PayloadType.EXECUTE_ACTION,
            payload: "",
            fee: "0",
            nonce: -1,
            signature: {
                signature_bytes: "",
                signature_type: signature_1.SignatureType.ACCOUNT_SECP256K1_UNCOMPRESSED
            },
            sender: "",
        };
        configure(tx);
        return new Transaction(tx);
    }
    Txn.create = create;
    function copy(source, configure) {
        return Txn.create((tx) => {
            tx.hash = "";
            tx.payload_type = source.payload_type;
            tx.payload = source.payload;
            tx.fee = source.fee;
            tx.nonce = source.nonce;
            tx.signature = {
                signature_bytes: "",
                signature_type: signature_1.SignatureType.ACCOUNT_SECP256K1_UNCOMPRESSED
            };
            tx.sender = source.sender;
            configure(tx);
        });
    }
    Txn.copy = copy;
})(Txn || (exports.Txn = Txn = {}));
//# sourceMappingURL=tx.js.map