"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var BasicColourPicker_1 = require("./elements/basic-colour-picker/BasicColourPicker");
var Observables_1 = require("./state/Observables");
var ColourMixer_1 = require("./colour/ColourMixer");
var Observable_1 = require("rxjs/Observable");

var ColourPicker = function () {
    function ColourPicker(options) {
        _classCallCheck(this, ColourPicker);

        this.options = options;
    }
    /**
     * bootstrap the instance
     * TODO  add alternative styles; library swatches, recently used colours, different colour wheels/formats, opacity
     */


    _createClass(ColourPicker, [{
        key: "bootstrap",
        value: function bootstrap() {
            //  create a basic colour picker
            BasicColourPicker_1.createBasicColourPicker(this.options);
            //  set the default colour
            this.setColour(this.options.defaultColour);
            //  add listeners
            this.addListeners();
        }
        /**
         * set the current colour for the picker
         * @param input
         */

    }, {
        key: "setColour",
        value: function setColour(input) {
            //  create and populate the colour picker popup
            this.colour = input;
            //  briefly set the active id
            Observables_1.activeID.next(this.options.id);
            //  convert the input to HSL and update observable HSL values
            ColourMixer_1.setObservableHSL(ColourMixer_1.inputToHSL(this.colour));
            //  reset the observable id
            Observables_1.activeID.next(null);
        }
        /**
         * add interaction listeners to the pane
         */

    }, {
        key: "addListeners",
        value: function addListeners() {
            var _this = this;

            //  subscribe to the active instance id
            Observables_1.activeID.takeUntil(this.options.destroy).delay(1).subscribe(function (id) {
                return _this.options.id === id ? _this.activatePane() : _this.deactivatePane();
            });
            //  listen for colour updates
            if (this.options.actions.liveUpdate) {
                //  subscribe to the observable hex and debounce so we're not updating the external watcher every tick;
                //  also add a filter condition to ensure we only dispatch the output when the picker is active -
                //  this avoids loops where the picker is externally updated
                this.observableColour = ColourMixer_1.autoObservableHex.filter(function (hex) {
                    return _this.active;
                }).debounce(function () {
                    return Observable_1.Observable.interval(100);
                });
            } else {
                //  if live update is disabled then only update the final output colour when the user clicks "confirm"
                this.observableColour = Observable_1.Observable.concat(ColourMixer_1.manualObservableHex);
            }
        }
        /**
         * activate the pane; start listening for relevant events
         */

    }, {
        key: "activatePane",
        value: function activatePane() {
            var _this2 = this;

            //  update the picker's current colour, with a short debounce
            ColourMixer_1.autoObservableHex.takeUntil(this.options.destroy).takeUntil(Observables_1.activeID).debounce(function () {
                return Observable_1.Observable.interval(1);
            }).subscribe(function (hex) {
                return _this2.colour = hex;
            });
            //  convert the input to HSL and update observable HSL values
            ColourMixer_1.setObservableHSL(ColourMixer_1.inputToHSL(this.colour));
            //  set active state
            this.active = true;
        }
        /**
         * deactivate the pane
         */

    }, {
        key: "deactivatePane",
        value: function deactivatePane() {
            //  set active state
            this.active = false;
        }
        /**
         * destroy this instance
         */

    }, {
        key: "destroy",
        value: function destroy() {
            //  dispatch the destroy signal
            this.options.destroy.next(true);
        }
    }]);

    return ColourPicker;
}();

exports.ColourPicker = ColourPicker;