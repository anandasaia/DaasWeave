"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * create and populate an SVG element
 * @param element
 * @return {SVGSVGElement}
 */
function createSvg(element) {
    var svgElement = void 0;
    //  create the new element
    svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    //  make the element fill its container
    fillContainer(svgElement);
    //  append the new element to the popup element
    element.appendChild(svgElement);
    //  return the new element
    return svgElement;
}
exports.createSvg = createSvg;
/**
 * create and append an SVG gradient
 * @param svg
 * @param id
 * @param type
 * @return {SVGGradientElement}
 */
function createSvgGradient(svg, id) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linearGradient';

    var svg_ns = void 0,
        defs = void 0,
        gradient = void 0;
    //  get SVG namespace
    svg_ns = svg.namespaceURI;
    //  create and append defs element
    defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS(svg_ns, 'defs'), svg.firstChild);
    //  create the gradient
    gradient = document.createElementNS(svg_ns, type);
    //  add an id (we need this to set the gradient as the fill of an element later)
    gradient.setAttribute('id', id);
    //  set direction
    gradient.setAttribute('x1', '0%');
    gradient.setAttribute('y1', '0%');
    gradient.setAttribute('x2', '0%');
    gradient.setAttribute('y2', '100%');
    //  append the gradient to the SVG defs
    defs.appendChild(gradient);
    //  return the gradient
    return gradient;
}
exports.createSvgGradient = createSvgGradient;
/**
 * create and append an SVG gradient
 * @param gradient
 * @param points
 * @return {SVGGradientElement}
 */
function setGradientDirection(gradient, points) {
    //  set direction
    gradient.setAttribute('x1', points[0]);
    gradient.setAttribute('y1', points[1]);
    gradient.setAttribute('x2', points[2]);
    gradient.setAttribute('y2', points[3]);
    //  return the gradient
    return gradient;
}
exports.setGradientDirection = setGradientDirection;
/**
 * populate a gradient with the given colour stops
 * @param gradient
 * @param stops
 */
function fillGradient(gradient, stops) {
    stops.forEach(function (stop) {
        var stopElement = void 0;
        //  create a new stop element
        stopElement = document.createElementNS(gradient.parentElement.namespaceURI, 'stop');
        //  set the stop's colour and position within the gradient
        stopElement.setAttribute('offset', stop.offset);
        stopElement.setAttribute('stop-color', stop.colour);
        stopElement.setAttribute('stop-opacity', stop.opacity || '1');
        //  append the stop to the gradient
        gradient.appendChild(stopElement);
    });
}
exports.fillGradient = fillGradient;
/**
 * create and append an SVG gradient
 * @param svg
 * @param gradient_id
 */
function createColourPaneSVGElement(svg, gradient_id) {
    var rect = void 0;
    //  create the new rect element
    rect = document.createElementNS(svg.namespaceURI, 'rect');
    //  make it fill the container
    rect.setAttribute('x', '0');
    rect.setAttribute('y', '0');
    rect.setAttribute('width', '100%');
    rect.setAttribute('height', '100%');
    //  fill it with the gradient
    rect.setAttribute('fill', 'url(' + svg.ownerDocument.defaultView.location.href + '#' + gradient_id + ')');
    //  add the rect to the page
    svg.appendChild(rect);
}
exports.createColourPaneSVGElement = createColourPaneSVGElement;
/**
 * make an element fill its container
 * @param element
 */
function fillContainer(element) {
    element.style.position = 'absolute';
    element.style.top = '0px';
    element.style.left = '0px';
    element.style.width = '100%';
    element.style.height = '100%';
}